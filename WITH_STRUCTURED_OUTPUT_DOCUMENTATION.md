# Structured Output Documentation

## Overview

The `with_structured_output` method provides a powerful way to get structured, validated output from the ChatGradient model. It supports two modes: with Pydantic schema validation and without schema (raw JSON).

## Method Signature

```python
def with_structured_output(
    self,
    schema: Optional[Union[Dict[str, Any], type]] = None,
    parsing_method: str = "json_parser",
    **kwargs: Any
) -> Runnable
```

## Parameters

- **schema** (Optional): Pydantic model class to validate output against. If `None`, returns raw JSON dict.
- **parsing_method** (str): Method to parse output. Currently supports "json_parser".
- **kwargs**: Additional keyword arguments passed to the model.

## Return Value

Returns a `Runnable` chain that:
- Takes `HumanMessage` or list of messages as input
- Returns either:
  - **Pydantic model instance** (if schema provided)
  - **Raw JSON dict** (if no schema provided)

## Usage Examples

### Mode 1: With Pydantic Schema (Validated Output)

```python
from pydantic import BaseModel, Field
from langchain_core.messages import HumanMessage
from langchain_gradient import ChatGradient

class Person(BaseModel):
    name: str = Field(description="The person's full name")
    age: int = Field(description="The person's age", ge=0, le=150)
    occupation: str = Field(description="The person's job or profession")

# Initialize model
chat = ChatGradient()

# Create structured output chain with schema
person_chain = chat.with_structured_output(Person)

# Use with HumanMessage
result = person_chain.invoke(HumanMessage(content="Tell me about Albert Einstein"))
print(f"Name: {result.name}")  # Validated Pydantic field
print(f"Age: {result.age}")    # Type-safe access
print(f"Occupation: {result.occupation}")

# Use with list of messages
result = person_chain.invoke([HumanMessage(content="Tell me about Marie Curie")])
```

### Mode 2: Without Schema (Raw JSON)

```python
# Create structured output chain without schema
json_chain = chat.with_structured_output()

# Returns raw JSON dict
result = json_chain.invoke(HumanMessage(content="Tell me about Nikola Tesla"))
print(f"Keys: {list(result.keys())}")  # ['name', 'age', 'occupation', ...]
print(f"Name: {result['name']}")       # Raw dict access

# Explicitly specify no schema
json_chain = chat.with_structured_output(schema=None)
```

## Error Handling

### JSON Parsing Errors
```python
try:
    result = chain.invoke(HumanMessage(content="Invalid input"))
except ValueError as e:
    print(f"JSON parsing failed: {e}")
    # Error includes response content for debugging
```

### Pydantic Validation Errors
```python
try:
    result = person_chain.invoke(HumanMessage(content="Invalid data"))
except ValueError as e:
    print(f"Validation failed: {e}")
    # Error includes validation details and JSON data
```

### Input Format Errors
```python
try:
    result = chain.invoke("invalid string input")
except ValueError as e:
    print(f"Invalid input format: {e}")
    # Error explains expected input format
```

## Advanced Usage

### Custom Model Parameters
```python
# Pass additional model parameters
person_chain = chat.with_structured_output(
    Person,
    temperature=0.7,
    max_tokens=100
)
```

### Different Parsing Methods
```python
# Currently only "json_parser" is supported
person_chain = chat.with_structured_output(Person, parsing_method="json_parser")
```

## Implementation Details

### Input Processing
The method automatically handles different input formats:
- **Single HumanMessage**: `HumanMessage(content="...")`
- **List of messages**: `[HumanMessage(content="...")]`

### Prompt Engineering
- **With schema**: Uses Pydantic format instructions for structured output
- **Without schema**: Uses generic JSON instructions

### JSON Parsing
- **With schema**: Pydantic validation with detailed error messages
- **Without schema**: Raw JSON parsing with error handling

## Best Practices

1. **Use Pydantic schemas** when you need type safety and validation
2. **Use raw JSON** when you need flexibility or don't have a fixed schema
3. **Handle errors gracefully** with try-catch blocks
4. **Test with various inputs** to ensure robust behavior
5. **Use descriptive field descriptions** in Pydantic models for better AI output

## Troubleshooting

### Common Issues

1. **"Invalid input format" error**: Ensure you're passing HumanMessage or list of messages
2. **JSON parsing errors**: Check that the AI is returning valid JSON
3. **Validation errors**: Verify your Pydantic schema matches the expected data structure
4. **Empty responses**: Check your prompt and ensure the AI has enough context

### Debug Tips

1. **Print the raw response** to see what the AI is returning
2. **Check the format instructions** generated by Pydantic
3. **Test with simple inputs** first before complex queries
4. **Use verbose error messages** to understand parsing failures
